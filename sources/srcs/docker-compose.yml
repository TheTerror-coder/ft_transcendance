name: ${PROJECT_NAME}

services:
  vault_init:
    image: ${VAULT_INIT_IMAGE}
    container_name: ${VAULT_INIT_CONTAINER}
    build:
      context: ./requirements/vault_init/
      args:
        - VAULT_VERSION=${VAULT_VERSION}
        - VAULT_UID=${VAULT_UID}
        - VAULT_GID=${VAULT_GID}
        - SHARED_GID=${SHARED_GID}
        - VAULT_HOME=${VAULT_HOME}
        - VAULT_INIT_DIRS_TO_MAKE=${VAULT_INIT_DIRS_TO_MAKE}
    environment:
      - VAULT_ADDR=${VAULT_INIT_ADDR}
      - VAULT_CACERT=${VAULT_INIT_CACERT}
      - VAULT_HOME=${VAULT_HOME}
      - VAULT_UID=${VAULT_UID}
      - VAULT_GID=${VAULT_GID}
      - WEB_UID=${WEB_UID}
      - WEB_GID=${WEB_GID}
      - SHARED_GID=${SHARED_GID}
      - ALT_NAMES=${ALT_NAMES}
      - MODSEC_ALT_NAMES=${MODSEC_ALT_NAMES}
      - WEB_ALT_NAMES=${WEB_ALT_NAMES}
      - VAULT_INIT_HEALTHFLAG=${VAULT_INIT_HEALTHFLAG}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    cap_add:
      - IPC_LOCK
    volumes:
      - vault_data:${VAULT_HOME}/volumes/vault/file
      - vault_healthiness:${VAULT_HOME}/volumes/healthiness
      - vault_certs:${VAULT_HOME}/volumes/vault/certs
      - nginx_certs:${VAULT_HOME}/volumes/nginx/certs
      - web_certs:${VAULT_HOME}/volumes/web/certs
    secrets:
      - root_access_token
      - secret_access_token
      - password_policy_json
      - secret_access_policy_json
      - pki_access_policy_json
      - pki_access_token
    networks:
      - transcendance
    healthcheck:
      test: ["CMD-SHELL", "test -f $HEALTHFLAG_FILE || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 2
    restart: on-failure

  vault:
    depends_on:
      vault_init:
        condition: service_healthy
        restart: true
    image: ${VAULT_IMAGE}
    container_name: ${VAULT_CONTAINER}
    build:
      context: ./requirements/vault/
      args:
        - VAULT_VERSION=${VAULT_VERSION}
        - VAULT_UID=${VAULT_UID}
        - VAULT_GID=${VAULT_GID}
        - SHARED_GID=${SHARED_GID}
        - VAULT_HOME=${VAULT_HOME}
        - VAULT_DIRS_TO_MAKE=${VAULT_DIRS_TO_MAKE}
    environment:
      - VAULT_ADDR=${VAULT_ADDR}
      - VAULT_CACERT=${VAULT_CACERT}
      - VAULT_SKIP_VERIFY=true
      - SKIP_SETCAP=true
      - VAULT_HEALTHFLAG=${VAULT_HEALTHFLAG}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    cap_add:
      - IPC_LOCK
    volumes:
      - vault_data:${VAULT_HOME}/file
      - vault_certs:${VAULT_HOME}/certs
      - vault_healthiness:${VAULT_HOME}/healthiness
    expose:
      - ${VAULT_API_PORT}
    ports:
      - ${VAULT_API_PORT}:${VAULT_API_PORT}
    networks:
      - transcendance
    healthcheck:
      test: ["CMD-SHELL", "test -f $VAULT_HEALTHFLAG || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 2
    restart: on-failure

  db_postgres:
    depends_on:
      vault:
        condition: service_healthy
        restart: true
    image: ${POSTGRES_IMAGE}
    container_name: ${POSTGRES_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/db_postgres/
      args:
        - POSTGRES_TAG=${POSTGRES_TAG}
        - POSTGRES_HOME=${POSTGRES_HOME}
        - POSTGRES_UID=${POSTGRES_UID}
        - POSTGRES_GID=${POSTGRES_GID}
        - SHARED_GID=${SHARED_GID}
        - POSTGRES_DIRS_TO_MAKE=${POSTGRES_DIRS_TO_MAKE}
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - VAULT_CACERT=${POSTGRES_VAULT_CACERT}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    volumes:
      - vault_certs:${POSTGRES_HOME}/volumes/vault/certs
    secrets:
      - secret_access_token
    healthcheck: #&file_healthcheck
      test: ["CMD-SHELL", "test -f $HEALTHFLAG_FILE || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    expose:
      - ${POSTGRES_PORT}
    networks:
      - ${NETWORK_NAME}
    restart: on-failure

  web:
    depends_on:
      db_postgres:
        condition: service_healthy
        restart: true
    image: ${WEB_IMAGE}
    container_name: ${WEB_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/web/
      args:
        - WEB_TAG=${WEB_TAG}
        - WEB_UID=${WEB_UID}
        - WEB_GID=${WEB_GID}
        - SHARED_GID=${SHARED_GID}
        - WEB_HOME=${WEB_HOME}
        - WEB_DIRS_TO_MAKE=${WEB_DIRS_TO_MAKE}
        - STATICFILES_DIR=${WEB_STATICFILES_DIR}
    environment:
      - WEB_ENTRYPOINT=${WEB_ENTRYPOINT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - RESOLVED_PG_HOSTNAME=${RESOLVED_PG_HOSTNAME}
      - GUNICORN_CMD_ARGS=${GUNICORN_CMD_ACTIVE_OPTIONS}
      - STATICFILES_DIR=${WEB_STATICFILES_DIR}
      - WEB_ROOT_CA=${WEB_ROOT_CA}
      - VAULT_CACERT=${WEB_VAULT_CACERT}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    volumes:
      - webapps:${WEB_HOME}/apps
      - staticfiles:${WEB_STATICFILES_DIR}
      - vault_certs:${WEB_HOME}/volumes/vault/certs
      - web_certs:${WEB_SSL_DIR}
    secrets:
      - secret_access_token
    healthcheck: #*file_healthcheck
      test:
        [
          "CMD-SHELL",
          # "curl -s http://localhost:${WEB_PORT} | grep -q ''",
          "curl -s --cacert $WEB_ROOT_CA https://localhost:${WEB_PORT} | grep -q ''", # In production
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    expose:
      - ${WEB_PORT}
    networks:
      - ${NETWORK_NAME}
    ports:
      - 8888:${WEB_PORT}
    restart: on-failure

  modsec:
    depends_on:
      web:
        condition: service_healthy
        restart: true
    image: ${MODSEC_IMAGE}
    container_name: ${MODSEC_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/modsec/
      args:
        - MODSECURITY_TAG=${MODSECURITY_TAG}
        - MODSEC_UID=${MODSEC_UID}
        - MODSEC_GID=${MODSEC_GID}
        - MODSEC_HOME=${MODSEC_HOME}
        - SHARED_GID=${SHARED_GID}
        - MODSEC_DIRS_TO_MAKE=${MODSEC_DIRS_TO_MAKE}
        - MODSEC_LOGS_ROOT=${MODSEC_LOGS_ROOT}
        - MODSEC_AUDIT_LOG_DIR=${MODSEC_AUDIT_LOG_DIR}
        - MODSEC_DEBUG_LOG_DIR=${MODSEC_DEBUG_LOG_DIR}
        - NGINX_STATICFILES_DIR=${NGINX_STATICFILES_DIR}
        - NGINX_LOG_FILES=${NGINX_LOG_FILES}
    environment:
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_HOME=${MODSEC_HOME}
      - NGINX_ROOT_CA=${NGINX_ROOT_CA}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      # - MODSEC_AUDIT_LOG=${MODSEC_AUDIT_LOG}
      # - MODSEC_DEBUG_LOG=${MODSEC_DEBUG_LOG}
      # - MODSEC_DEBUG_LOGLEVEL=${MODSEC_DEBUG_LOGLEVEL}
    volumes:
      - ./requirements/modsec/conf/default.conf.template:/etc/nginx/templates/conf.d/default.conf.template
      - ./requirements/modsec/conf/vault.conf.template:/etc/nginx/templates/conf.d/vault.conf.template
      - ./requirements/modsec/conf/location_common.conf.template:/etc/nginx/templates/includes/location_common.conf.template
      - ./requirements/modsec/conf/logging.conf.template:/etc/nginx/templates/conf.d/logging.conf.template
      # - ./requirements/modsec/conf/modsecurity-override.conf.template:/etc/nginx/templates/modsecurity.d/modsecurity-override.conf.template
      - staticfiles:${NGINX_STATICFILES_DIR}
      - modsec_data:${MODSEC_DATA_DIR}
      # - modsec_audit_logs:${MODSEC_AUDIT_LOG_DIR}
      # - modsec_debug_logs:${MODSEC_DEBUG_LOG_DIR}
      # - nginx_logs:${NGINX_LOG_FILES_DIR}
      - nginx_certs:${MODSEC_HOME}/volumes/nginx/certs
      - vault_certs:${MODSEC_HOME}/volumes/vault/certs
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert $NGINX_ROOT_CA https://localhost:8443 > /dev/null",
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    ports:
      - ${MODSEC_HTTP_PORT}:8080
      - ${MODSEC_HTTPS_PORT}:8443
    networks:
      - ${NETWORK_NAME}
    restart: on-failure
  
  ready:
    depends_on:
      modsec:
        condition: service_healthy
        restart: true
    image: alpine:${ALPINE_VERSION}
    container_name: ready_c
    command: echo "Microservices Infrastructure is ready and healthy!"
    restart: on-failure
  
networks:
  transcendance:
    driver: bridge

volumes:
  vault_data:
    driver: local
  vault_healthiness:
    driver: local
  modsec_data:
    driver: local
  modsec_audit_logs:
    driver: local
  modsec_debug_logs:
    driver: local
  nginx_logs:
    driver: local
  webapps:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${WEBAPPS_VOLUME}
  staticfiles:
    driver: local
  certs:
    driver: local
  vault_certs:
    driver: local
  nginx_certs:
    driver: local
  web_certs:
    driver: local

secrets:
  secret_access_token:
    file: ./secrets/secret_access_token
  root_access_token: # TODO remove on production
    file: ./secrets/root_access_token
  password_policy_json:
    file: ./secrets/password_policy_json
  secret_access_policy_json:
    file: ./secrets/secret_access_policy_json
  pki_access_policy_json:
    file: ./secrets/pki_access_policy_json
  pki_access_token:
    file: ./secrets/pki_access_token