name: ${PROJECT_NAME}

services:
  vault_init:
    image: ${VAULT_INIT_IMAGE}
    container_name: ${VAULT_INIT_CONTAINER}
    build:
      context: ./requirements/vault_init/
      args:
        - VAULT_VERSION=${VAULT_VERSION}
        - VAULT_UID=${VAULT_UID}
        - VAULT_GID=${VAULT_GID}
        - SHARED_GID=${SHARED_GID}
        - VAULT_HOME=${VAULT_HOME}
        - VAULT_INIT_DIRS_TO_MAKE=${VAULT_INIT_DIRS_TO_MAKE}
    environment:
      - SECRET_ACCESS_TOKEN=${SECRET_ACCESS_TOKEN}
      - PKI_ACCESS_TOKEN=${PKI_ACCESS_TOKEN}
      - ROOT_ACCESS_TOKEN=${ROOT_ACCESS_TOKEN}
      - VAULT_ADDR=${VAULT_INIT_ADDR}
      - VAULT_CACERT=${VAULT_INIT_CACERT}
      - VAULT_HOME=${VAULT_HOME}
      - VAULT_UID=${VAULT_UID}
      - VAULT_GID=${VAULT_GID}
      - WEB_UID=${WEB_UID}
      - WEB_GID=${WEB_GID}
      - SHARED_GID=${SHARED_GID}
      - ALT_NAMES=${ALT_NAMES}
      - MODSEC_ALT_NAMES=${MODSEC_ALT_NAMES}
      - WEB_ALT_NAMES=${WEB_ALT_NAMES}
      - VAULT_INIT_HEALTHFLAG=${VAULT_INIT_HEALTHFLAG}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    cap_add:
      - IPC_LOCK
    volumes:
      - vault_data:${VAULT_HOME}/volumes/vault/file
      - vault_healthiness:${VAULT_HOME}/volumes/healthiness
      - vault_certs:${VAULT_HOME}/volumes/vault/certs
      - nginx_certs:${VAULT_HOME}/volumes/nginx/certs
      - gameserver_certs:${VAULT_HOME}/volumes/gameserver/certs
      - web_certs:${VAULT_HOME}/volumes/web/certs
      - node_certs:${VAULT_HOME}/volumes/node/certs
    networks:
      - transcendance
    healthcheck:
      test: ["CMD-SHELL", "test -f $HEALTHFLAG_FILE || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 2
    restart: on-failure

  vault:
    depends_on:
      vault_init:
        condition: service_healthy
        restart: true
    image: ${VAULT_IMAGE}
    container_name: ${VAULT_CONTAINER}
    build:
      context: ./requirements/vault/
      args:
        - VAULT_VERSION=${VAULT_VERSION}
        - VAULT_UID=${VAULT_UID}
        - VAULT_GID=${VAULT_GID}
        - SHARED_GID=${SHARED_GID}
        - VAULT_HOME=${VAULT_HOME}
        - VAULT_DIRS_TO_MAKE=${VAULT_DIRS_TO_MAKE}
    environment:
      - VAULT_ADDR=${VAULT_ADDR}
      - VAULT_CACERT=${VAULT_CACERT}
      - VAULT_SKIP_VERIFY=true
      - SKIP_SETCAP=true
      - VAULT_HEALTHFLAG=${VAULT_HEALTHFLAG}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    cap_add:
      - IPC_LOCK
    volumes:
      - vault_data:${VAULT_HOME}/file
      - vault_certs:${VAULT_HOME}/certs
      - vault_healthiness:${VAULT_HOME}/healthiness
    expose:
      - ${VAULT_API_PORT}
    ports:
      - ${VAULT_API_PORT}:${VAULT_API_PORT}
    networks:
      - transcendance
    healthcheck:
      test: ["CMD-SHELL", "test -f $VAULT_HEALTHFLAG || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 2
    restart: on-failure

  db_postgres:
    depends_on:
      vault:
        condition: service_healthy
        restart: true
    image: ${POSTGRES_IMAGE}
    container_name: ${POSTGRES_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/db_postgres/
      args:
        - POSTGRES_TAG=${POSTGRES_TAG}
        - POSTGRES_HOME=${POSTGRES_HOME}
        - POSTGRES_UID=${POSTGRES_UID}
        - POSTGRES_GID=${POSTGRES_GID}
        - SHARED_GID=${SHARED_GID}
        - POSTGRES_DIRS_TO_MAKE=${POSTGRES_DIRS_TO_MAKE}
    environment:
      - SECRET_ACCESS_TOKEN=${SECRET_ACCESS_TOKEN}
      - POSTGRES_HOME=${POSTGRES_HOME}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - VAULT_CACERT=${POSTGRES_VAULT_CACERT}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
    volumes:
      - vault_certs:${POSTGRES_HOME}/volumes/vault/certs
    healthcheck: #&file_healthcheck
      test: ["CMD-SHELL", "test -f $HEALTHFLAG_FILE || exit 1"]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    expose:
      - ${POSTGRES_PORT}
    networks:
      - ${NETWORK_NAME}
    restart: on-failure

  web:
    depends_on:
      db_postgres:
        condition: service_healthy
        restart: true
    image: ${WEB_IMAGE}
    container_name: ${WEB_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/web/
      args:
        - PYTHON_TAG=${WEB_TAG}
        - PYTHON_UID=${WEB_UID}
        - PYTHON_USER=${WEB_USER}
        - PYTHON_GID=${WEB_GID}
        - PYTHON_SRCS=${WEB_SRCS}
        - SHARED_GID=${SHARED_GID}
        - PYTHON_HOME=${WEB_HOME}
        - PYTHON_DIRS_TO_MAKE=${WEB_DIRS_TO_MAKE}
        - STATICFILES_DIR=${WEB_STATICFILES_DIR}
        - STATICFILES_DIR=${STATICFILES_DIR}
        - HOST_IP=${HOST_IP}
    environment:
      - SECRET_ACCESS_TOKEN=${SECRET_ACCESS_TOKEN}
      - PYTHON_HOME=${WEB_HOME}
      - PYTHON_ENTRYPOINT=${WEB_ENTRYPOINT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - RESOLVED_PG_HOSTNAME=${RESOLVED_PG_HOSTNAME}
      - GUNICORN_CMD_ARGS=${GUNICORN_CMD_ACTIVE_OPTIONS}
      - STATICFILES_DIR=${WEB_STATICFILES_DIR}
      - WEB_ROOT_CA=${WEB_ROOT_CA}
      - VAULT_CACERT=${WEB_VAULT_CACERT}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
      - HOST_IP=${HOST_IP}
      - WEB_PORT=${WEB_PORT}
    volumes:
      - webapps:${WEB_HOME}/apps
      - staticfiles:${WEB_STATICFILES_DIR}
      - vault_certs:${WEB_HOME}/volumes/vault/certs
      - web_certs:${WEB_SSL_DIR}
    healthcheck: #*file_healthcheck
      test:
        [
          "CMD-SHELL",
          "curl -s http://localhost:$WEB_PORT/healthcheck/ | grep -q 'healthy'",
          # "curl -s --cacert $WEB_ROOT_CA https://localhost:$WEB_PORT/healthcheck/ | grep -q 'healthy'", # In production
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    expose:
      - ${WEB_PORT}
    networks:
      - ${NETWORK_NAME}
    ports:
      - 8888:${WEB_PORT}
    restart: on-failure
  
  gameserver:
    depends_on:
      db_postgres:
        condition: service_healthy
        restart: true
    image: ${GAMESERVER_IMAGE}
    container_name: ${GAMESERVER_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/web/
      args:
        - PYTHON_TAG=${GAMESERVER_TAG}
        - PYTHON_UID=${GAMESERVER_UID}
        - PYTHON_GID=${GAMESERVER_GID}
        - PYTHON_USER=${GAMESERVER_USER}
        - PYTHON_SRCS=${GAMESERVER_SRCS}
        - SHARED_GID=${SHARED_GID}
        - PYTHON_HOME=${GAMESERVER_HOME}
        - PYTHON_DIRS_TO_MAKE=${GAMESERVER_DIRS_TO_MAKE}
        - STATICFILES_DIR=${GAMESERVER_STATICFILES_DIR}
        - STATICFILES_DIR=${STATICFILES_DIR}
        - HOST_IP=${HOST_IP}
    environment:
      - SECRET_ACCESS_TOKEN=${SECRET_ACCESS_TOKEN}
      - PYTHON_HOME=${GAMESERVER_HOME}
      - PYTHON_ENTRYPOINT=${GAMESERVER_ENTRYPOINT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - RESOLVED_PG_HOSTNAME=${RESOLVED_PG_HOSTNAME}
      - GUNICORN_CMD_ARGS=${GUNICORN_CMD_ACTIVE_OPTIONS}
      - STATICFILES_DIR=${GAMESERVER_STATICFILES_DIR}
      - GAMESERVER_ROOT_CA=${GAMESERVER_ROOT_CA}
      - VAULT_CACERT=${GAMESERVER_VAULT_CACERT}
      - HEALTHFLAG_FILE=${HEALTHFLAG_FILE}
      - HOST_IP=${HOST_IP}
      - GAMESERVER_PORT=${GAMESERVER_PORT}
    volumes:
      - vault_certs:${GAMESERVER_HOME}/volumes/vault/certs
      - gameserver_certs:${GAMESERVER_SSL_DIR}
    healthcheck: #*file_healthcheck
      test:
        [
          "CMD-SHELL",
          # "curl -s http://localhost:${GAMESERVER_PORT}/healthcheck/ | grep -q ''",
          "curl -s --cacert $GAMESERVER_ROOT_CA https://localhost:$GAMESERVER_PORT/healthcheck/ | grep -q 'healthy'", # In production
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    expose:
      - ${GAMESERVER_PORT}
      - 3000
    networks:
      - ${NETWORK_NAME}
    ports:
      - ${GAMESERVER_PORT}:${GAMESERVER_PORT}
      - 3000:3000
    restart: on-failure
  
  # node:
  #   depends_on:
  #     db_postgres:
  #       condition: service_healthy
  #       restart: true
  #   image: ${NODE_IMAGE}
  #   container_name: ${NODE_CONTAINER}
  #   pull_policy: never
  #   build:
  #     context: ./requirements/node/
  #     args:
  #       - NODE_TAG=${NODE_TAG}
  #       - NODE_UID=${NODE_UID}
  #       - NODE_GID=${NODE_GID}
  #       - SHARED_GID=${SHARED_GID}
  #       - NODE_HOME=${NODE_HOME}
  #       - NODE_DIRS_TO_MAKE=${NODE_DIRS_TO_MAKE}
  #   environment:
  #     - HOST_IP=${HOST_IP}
  #   volumes:
  #     - node_certs:${NODE_SSL_DIR}
  #     - web_certs:${NODE_HOME}/volumes/web/certs
  #   expose:
  #     - ${NODE_PORT}
  #   networks:
  #     - ${NETWORK_NAME}
  #   ports:
  #     - ${NODE_PORT}:${NODE_PORT}
  #   # healthcheck: #*file_healthcheck
  #   #   test:
  #   #     [
  #   #       "CMD-SHELL",
  #   #       "curl -s http://localhost:${WEB_PORT} | grep -q ''",
  #   #       # "curl -s --cacert $WEB_ROOT_CA https://localhost:${WEB_PORT} | grep -q ''", # In production
  #   #     ]
  #   #   start_period: 10s
  #   #   interval: 10s
  #   #   timeout: 5s
  #   #   retries: 1
  #   # restart: on-failure

  web_waf:
    depends_on:
      web:
        condition: service_healthy
        restart: true
    image: ${WEBWAF_IMAGE}
    container_name: ${WEBWAF_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/waf/
      args:
        - MODSECURITY_TAG=${MODSECURITY_TAG}
        - NGINX_UID=${NGINX_UID}
        - NGINX_GID=${NGINX_GID}
        - MODSEC_HOME=${MODSEC_HOME}
        - SHARED_GID=${SHARED_GID}
        - MODSEC_DIRS_TO_MAKE=${MODSEC_DIRS_TO_MAKE}
        - MODSEC_LOGS_ROOT=${MODSEC_LOGS_ROOT}
        - MODSEC_AUDIT_LOG_DIR=${MODSEC_AUDIT_LOG_DIR}
        - MODSEC_DEBUG_LOG_DIR=${MODSEC_DEBUG_LOG_DIR}
        - NGINX_STATICFILES_DIR=${NGINX_STATICFILES_DIR}
        - NGINX_LOG_FILES=${NGINX_LOG_FILES}
        - REVERSEPROXY_CONF_FILE=./conf/web.conf.template
    environment:
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_HOME=${MODSEC_HOME}
      - NGINX_ROOT_CA=${NGINX_ROOT_CA}
      - WEBWAF_HTTP_PORT=${WEBWAF_HTTP_PORT}
      - WEBWAF_HTTPS_PORT=${WEBWAF_HTTPS_PORT}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      # - MODSEC_AUDIT_LOG=${MODSEC_AUDIT_LOG}
      # - MODSEC_DEBUG_LOG=${MODSEC_DEBUG_LOG}
      # - MODSEC_DEBUG_LOGLEVEL=${MODSEC_DEBUG_LOGLEVEL}
    volumes:
      # - ./requirements/waf/conf/modsecurity-override.conf.template:/etc/nginx/templates/modsecurity.d/modsecurity-override.conf.template
      - staticfiles:${NGINX_STATICFILES_DIR}
      - modsec_data:${MODSEC_DATA_DIR}
      # - modsec_audit_logs:${MODSEC_AUDIT_LOG_DIR}
      # - modsec_debug_logs:${MODSEC_DEBUG_LOG_DIR}
      # - nginx_logs:${NGINX_LOG_FILES_DIR}
      - nginx_certs:${MODSEC_HOME}/volumes/nginx/certs
      - vault_certs:${MODSEC_HOME}/volumes/vault/certs
    ports:
      - ${WEBWAF_HTTP_PORT}:${WEBWAF_HTTP_PORT}
      - ${WEBWAF_HTTPS_PORT}:${WEBWAF_HTTPS_PORT}
    networks:
      - ${NETWORK_NAME}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert $NGINX_ROOT_CA https://localhost:${WEBWAF_HTTPS_PORT} > /dev/null",
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    restart: on-failure

  vault_waf:
    depends_on:
      vault:
        condition: service_healthy
        restart: true
    image: ${VAULTWAF_IMAGE}
    container_name: ${VAULTWAF_CONTAINER}
    pull_policy: never
    build:
      context: ./requirements/waf/
      args:
        - MODSECURITY_TAG=${MODSECURITY_TAG}
        - NGINX_UID=${NGINX_UID}
        - NGINX_GID=${NGINX_GID}
        - MODSEC_HOME=${MODSEC_HOME}
        - SHARED_GID=${SHARED_GID}
        - MODSEC_DIRS_TO_MAKE=${MODSEC_DIRS_TO_MAKE}
        - MODSEC_LOGS_ROOT=${MODSEC_LOGS_ROOT}
        - MODSEC_AUDIT_LOG_DIR=${MODSEC_AUDIT_LOG_DIR}
        - MODSEC_DEBUG_LOG_DIR=${MODSEC_DEBUG_LOG_DIR}
        - NGINX_STATICFILES_DIR=${NGINX_STATICFILES_DIR}
        - NGINX_LOG_FILES=${NGINX_LOG_FILES}
        - REVERSEPROXY_CONF_FILE=./conf/vault.conf.template
    environment:
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_HOME=${MODSEC_HOME}
      - NGINX_ROOT_CA=${NGINX_ROOT_CA}
      - VAULTWAF_HTTP_PORT=${VAULTWAF_HTTP_PORT}
      - VAULTWAF_HTTPS_PORT=${VAULTWAF_HTTPS_PORT}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      - MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS}
      # - MODSEC_AUDIT_LOG=${MODSEC_AUDIT_LOG}
      # - MODSEC_DEBUG_LOG=${MODSEC_DEBUG_LOG}
      # - MODSEC_DEBUG_LOGLEVEL=${MODSEC_DEBUG_LOGLEVEL}
    volumes:
      # - ./requirements/waf/conf/modsecurity-override.conf.template:/etc/nginx/templates/modsecurity.d/modsecurity-override.conf.template
      - modsec_data:${MODSEC_DATA_DIR}
      # - modsec_audit_logs:${MODSEC_AUDIT_LOG_DIR}
      # - modsec_debug_logs:${MODSEC_DEBUG_LOG_DIR}
      # - nginx_logs:${NGINX_LOG_FILES_DIR}
      - nginx_certs:${MODSEC_HOME}/volumes/nginx/certs
      - vault_certs:${MODSEC_HOME}/volumes/vault/certs
    ports:
      - ${VAULTWAF_HTTP_PORT}:${VAULTWAF_HTTP_PORT}
      - ${VAULTWAF_HTTPS_PORT}:${VAULTWAF_HTTPS_PORT}
    networks:
      - ${NETWORK_NAME}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert $NGINX_ROOT_CA https://localhost:${VAULTWAF_HTTPS_PORT} > /dev/null",
        ]
      start_period: 10s
      interval: 10s
      timeout: 5s
      retries: 1
    restart: on-failure
  
  ready:
    depends_on:
      gameserver:
        condition: service_healthy
        restart: true
      web_waf:
        condition: service_healthy
        restart: true
      vault_waf:
        condition: service_healthy
        restart: true
    image: alpine:${ALPINE_VERSION}
    container_name: ready_c
    command: echo "Microservices Infrastructure is ready and healthy!"
    restart: on-failure
  
networks:
  transcendance:
    driver: bridge

volumes:
  vault_data:
    driver: local
  vault_healthiness:
    driver: local
  modsec_data:
    driver: local
  modsec_audit_logs:
    driver: local
  modsec_debug_logs:
    driver: local
  nginx_logs:
    driver: local
  webapps:
    driver: local
    # driver_opts:
    #   type: none
    #   o: bind
    #   device: ${WEBAPPS_VOLUME}
  staticfiles:
    driver: local
  certs:
    driver: local
  vault_certs:
    driver: local
  nginx_certs:
    driver: local
  web_certs:
    driver: local
  gameserver_certs:
    driver: local
  node_certs:
    driver: local
